import 'dart:io';

import 'package:path/path.dart';

extension on String {
  Directory get dir => Directory(this);
  File get file => File(this);
}

extension on Directory {
  File file(String path) => join(this.path, path).file;
  Directory dir(String path) => join(this.path, path).dir;
}

extension on FileSystemEntity {
  String get name => basename(path);
}

extension on IOSink {
  void w(String s) => write(s);
  void nl() => w("\n");
  void l(String s) {
    w(s);
    nl();
  }

  void i([int level = 1]) => w('\t' * level);
}

extension on int {
  Iterable<int> iter({int start = 0}) sync* {
    for (int i = start; i < this + start; i++) {
      yield i;
    }
  }
}

const startCount = 2;
const endCount = 15;

final autoGenerated = "// Auto generated by `${fThis.name}`. Do not modify!";

final fThis = Platform.script.toFilePath().file;
final dThis = fThis.parent;
final dpotatoparser = dThis;

final dLib = dpotatoparser.dir("lib");
final dOut = dLib.dir("src").dir("record_extensions");
final fLibrary = dOut.file("record_extensions.dart");

void main(List<String> args) async {
  await dOut.create(recursive: true);

  final wLibrary = fLibrary.openWrite(mode: FileMode.write);
  wLibrary.l(autoGenerated);
  wLibrary.l("import 'package:potatoparser/potatoparser.dart' as p;");

  for (int iExt = startCount; iExt <= endCount; iExt++) {
    final fExt = dOut.file("ext$iExt.dart");
    final wExt = fExt.openWrite(mode: FileMode.write);

    wExt.l(autoGenerated);
    wExt.l("part of '${fLibrary.name}';");

    wExt.w("extension RecordOf${iExt}ParsersExt");
    wExt.w("<");
    wExt.w(iExt.iter().map((n) => "T$n").join(", "));
    wExt.w(">");

    wExt.w(" on (");
    wExt.w(iExt.iter().map((n) => "p.Parser<T$n>").join(", "));
    wExt.l(") {");

    wExt.i();
    wExt.w("p.Parser<(");
    wExt.w(iExt.iter().map((n) => "T$n").join(", "));
    wExt.w(")> toParser() => p.list([");
    wExt.w(iExt.iter(start: 1).map((n) => "\$$n").join(", "));
    wExt.w("]).mapOk((v) => (");
    wExt.w(iExt.iter().map((n) => "v[$n] as T$n").join(", "));
    wExt.w("));");

    wExt.l("}");

    /// Extensions for the record parser

    wExt.nl();
    wExt.w("extension E${iExt}ParsersExt");
    wExt.w("<");
    wExt.w(iExt.iter().map((n) => "T$n").join(", "));
    wExt.w(">");

    wExt.w(" on p.Parser<(");
    wExt.w(iExt.iter().map((n) => "T$n").join(", "));
    wExt.l(")> {");

    wExt.l(
      "\tp.Parser<T${iExt.iter().last}> get onlyLast => mapOk((v) => v.\$$iExt);",
    );

    wExt.l(
      "\tp.Parser<T0> get onlyFirst => mapOk((v) => v.\$1);",
    );

    wExt.l("}");

    await wExt.close();

    wLibrary.l("part '${fExt.name}';");
  }

  await wLibrary.close();
}
